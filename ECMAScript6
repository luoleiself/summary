### let 和 const 命令
    1. let 命令: 
      * let命令声明的变量只在所在的代码块内有效
      `for(let i=0;i<10;i++){};`
      * let命令不存在声明提前
      * 暂时性死区(tmporal dead zone):暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量
        `function bar(x=y,y=2){};bar();//报错,y还没有声明`
        `function bar(x=2,y=x){};bar();//[2,2],x已经声明了`
      * 不允许重复声明:let不允许在相同作用域内，重复声明同一个变量,内层作用域可以定义外层作用域的同名变量
        `function add(){var a=10;let a=1;}; === function add(){let a=10;let a=1;}//报错`
        `function add(arg){let arg};//报错`
        `function fn(arg){{let arg}};//不报错`
        `{{{let a="Hello World"}}let a="Hello GitHub"};//不报错`
      * 块级作用域:
        * 第一种场景:内层变量可能会覆盖外层变量
          `var tmp = new Date();function f(){console.log(tmp);if (false) {var tmp = "hello world";}}f();//报错,undefind`
        * 第二种场景:用来计数的循环变量泄露为全局变量
          `var s = 'hello';for (var i = 0; i < s.length; i++) {console.log(s[i]);}console.log(i); // 5`
      * 块级作用域和函数声明:ES5规定，函数只能在顶层作用域和函数作用域之中声明，不能在块级作用域声明,严格模式下会报错`use strict`
        * ES6的块级作用域允许声明函数的规则，只在使用大括号的情况下成立，如果没有使用大括号，就会报错
        * ES6规定: 在块级作用域声明的函数在块级作用域范围之外不可引用
          1. 允许在块级作用域内声明函数
          2. 函数声明类似于var，即会提升到全局作用域或函数作用域的头部
          3. 同时，函数声明还会提升到所在的块级作用域的头部
      * do表达式: 获取块级作用域的值
        `{let t=fn();t=t*t+1;};//块级作用域不返回值,无法获取t的值`
        `let x = do{let t=fn();t=t*t+1;};//获取块级作用域的值赋值给x`
    2. const 命令:
      * const PI = "3.1415926";
      * 只在声明所在的块级作用域内有效,不会声明提前,和let的用法一致
      * 声明一个只读的常量。一旦声明，常量的值就不能改变
      * 一旦声明变量，就必须立即初始化,否则报错
      * 对于复合类型的变量，变量名不指向数据，而是指向数据所在的地址。const命令只是保证变量名指向的地址不变，并不保证该地址的数据不变
        `const foo = {};foo.prop = 123;foo.prop// 123`
        `foo = {}; // TypeError: "foo" is read-only`
      * 如果真的想将对象冻结，应该使用Object.freeze方法 `const foo = Object.freeze({});`
    3. 顶层对象的属性:在浏览器环境指的是window对象，在Node指的是global对象,ES5之中，顶层对象的属性与全局变量是等价的
      * ES6中，由let,const,class声明的变量不在属于顶层对象
    4. global对象:
      * 浏览器里面，顶层对象是window，但 Node 和 Web Worker 没有window
      * 浏览器和 Web Worker 里面，self也指向顶层对象，但是Node没有self
      * Node 里面，顶层对象是global，但其他环境都不支持
        `// 方法一`
        `(typeof window !== 'undefined' ? window : (typeof process === 'object' &&`
        `typeof require === 'function' && typeof global === 'object') ? global : this);`
        `// 方法二`
        `var getGlobal = function () {`
        `if (typeof self !== 'undefined') { return self; }`
        `if (typeof window !== 'undefined') { return window; }`
        `if (typeof global !== 'undefined') { return global; }`
        `throw new Error('unable to locate global object');};`
### 变量的解构赋值
    1. 数组的解构赋值：从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）,如果解构不成功，变量的值就等于undefined
       `let [head, ...tail] = [1, 2, 3, 4];//head => 1; tail => [2,3,4]`       
       * 完全解构
         `var [a, b, c] = [1, 2, 3];`
       * 不完全解构
         `let [x, y] = [1, 2, 3];//x => 1, y => 2;`
       * 默认值：如果一个数组成员不严格等于undefined，默认值是不会生效的 
         `var [x = 1] = [null];//x => null;`
         `var [x = 1] = [undefined];//x => 1`
    2. 对象的解构赋值: 对象解构时变量名必须和属性名一致,排列次序可以不一致,如果解构失败，属性名的值就等于undefined
       `var { bar, foo } = { foo: "aaa", bar: "bbb" };// bar => "aaa", foo => "bbb"`
       * 变量名与属性名不一致的情况
         `var { foo: baz } = { foo: 'aaa', bar: 'bbb' };// baz => "aaa"; foo是模式,baz才是变量`
       * 默认值: 如果一个对象成员的属性不严格等于undefined，默认值是不会生效的
         `var {x, y = 5} = {x: 1};// x => 1, y => 5;`
         `var {x = 3} = {x: undefined};//x => 3;`
         `var {x = 3} = {x: null};//x => null;`
       * 解构模式是嵌套的对象，而且子对象所在的父属性不存在，那么将会报错
         `var {foo: {bar}} = {baz: 'baz'};//报错`
       * 如果变量声明和解构赋值分开执行，则需要将赋值操作放在一个小括号内
         `var/let/const x;`
         `({x} = {x: 1});`
       * 数组解构和对象解构之间的转换
         `var {0 : first, [arr.length - 1] : last} = [1,2,3];// first => 1, last => 3;`
    3. 字符串的解构赋值:字符串被转换成了一个类似数组的对象
       `const [a, b, c, d, e] = 'hello';// a => 'h'...;`
    4. 数值和布尔值的解构赋值:解构赋值时，如果等号右边是数值和布尔值，则会先转为对象
       `let {toString: s} = 123;`
       `s === Number.prototype.toString // true`
       `let {toString: s} = true;`
       `s === Boolean.prototype.toString // true`
       * 总结: 解构赋值的规则是，只要等号右边的值不是对象，就先将其转为对象。由于undefined和null无法转为对象，所以对它们进行解构赋值，都会报错
    5. 函数参数的解构赋值
       `[[1, 2], [3, 4]].map(([a, b]) => a + b);// [3,7]`
       * 默认值:
         * 第一种情况: 给函数的参数的变量x,y指定默认值，如果函数参数解构失败,则参数等于默认值
         `function move({x = 0, y = 0} = {}) {`
          `return [x, y];`
         `}`
         `move({x: 3, y: 8}); // [3, 8]`
         `move({x: 3}); // [3, 0]`
         `move({}); // [0, 0]`
         `move(); // [0, 0]`
         * 第二种情况: 给函数的参数指定默认值，而不是变量x,y
         `function move({x, y} = { x: 0, y: 0 }) {`
          `return [x, y];`
         `}`
         `move({x: 3, y: 8}); // [3, 8]`
         `move({x: 3}); // [3, undefined]`
         `move({}); // [undefined, undefined]`
         `move(); // [0, 0]`
    6. 圆括号问题：只要有可能导致解构的歧义，就不得使用圆括号
       1. 不可用：
          * 变量声明语句中，不能带有圆括号
            `var {x: (c)} = {};//报错`
            `var [(a)] = [1];//报错`
          * 函数参数中，模式不能带有圆括号：函数参数也属于变量声明
            `function f([(z)]) { return z; };//报错`
          * 赋值语句中，不能将整个模式，或嵌套模式中的一层，放在圆括号之中
            `({ p: a }) = { p: 42 };//报错`
            `([a]) = [5];//报错`
       2. 赋值语句的非模式部分，可以使用圆括号:
          `[(b)] = [3]; // 正确`
          `({ p: (d) } = {}); // 正确`
          `[(parseInt.prop)] = [3]; // 正确`
    7. 用途
       1. 交换变量的值: `[x, y] = [y, x];`
       2. 从函数返回多个值：
       3. 函数参数的定义：
          `// 参数是一组有次序的值`
          `function f([x, y, z]) { ... }`
          `f([1, 2, 3]);`
          `// 参数是一组无次序的值`
          `function f({x, y, z}) { ... }`
          `f({z: 3, y: 2, x: 1});`
       4. 提取JSON数据:
       5. 函数参数的默认值:
       6. 遍历Map结构
       7. 输入模块的指定方法:`const { SourceMapConsumer, SourceNode } = require("source-map");`
### 字符串的扩展
    1. 字符的Unicode表示法
    2. codePointAt()
    3. String.fromCodePoint()
    4. 字符串的遍历接口
    5. at()
    6. normalize()
    7. includes(),startsWith(),endsWith()
    8. repeat()
    9. padStart(),padEnd()
    10. 模版字符串
    11. 实例: 模版编译
    12. 标签模版
    13. String.raw()
    14. 模版字符串的限制
