# Vue 3.x

## 应用配置

```javascript
// 每个 Vue 应用会暴露一个 config 对象, 在挂载应用之前, 可修改其属性
import { createApp } from 'vue';
const app = createApp({});
console.log(app.config);
```

- errorHandler 处理组件渲染过程中抛出的未捕获错误

  - 类型: Function
  - 默认: undefined

  ```javascript
  app.config.errorHandler = (err, vm, info) => {
    // 处理错误
  };
  ```

- warnHandler 处理 Vue 运行中的警告, 开发环境下有效

  - 类型: Function
  - 默认: undefined

  ```javascript
  app.config.warnHandler = (msg, vm, trace) => {
    // 处理警告
  };
  ```

- globalProperties 添加应用程序内任何组件实例都可访问的全局 property, 属性名冲突时,组件内 property 优先

  - 类型: [key: string]: any
  - 默认: undefined

  ```javascript
  // Vue 2.x
  Vue.prototype.$xhr = () => {};
  // Vue 3.x
  app.config.globalProperties.$xhr = () => {};
  ```

- isCustomElement 指定一个方法, 用来识别在 Vue 之外定义的自定义元素, 如果组件符合此条件, 则不需要本地或全局注册

  > 注意, 所有原生 HTML 和 SVG 标记不需要在此函数中匹配——Vue 解析器自动执行此检查

  - 类型: (tag: string) => boolean
  - 默认: undefined

  ```javascript
  app.config.isCustomElement = (tag) => tag.startsWith('icon-');
  ```

- optionMergeStrategies 合并策略选项分别接收在父实例和子实例上定义的该选项的值作为第一个和第二个参数, 引用上下文实例被作为第三个参数传入

  - 类型: { [key: string]: Function }
  - 默认: {}

  ```javascript
  const app = Vue.createApp({
    mounted() {
      console.log(this.$options.hello);
    },
  });
  app.config.optionMergeStrategies.hello = (parent, child, vm) => {
    return `Hello, ${child}`;
  };
  app.mixin({
    hello: 'Vue',
  });
  // 'Hello, Vue'
  ```

- performance 启用对组件初始化、编译、渲染和更新的性能追踪

  - 类型: boolean
  - 默认: false

  ```javascript
  app.config.performance = true;
  ```

## 应用 API

> 调用 createApp 返回一个应用实例，该实例提供了一个应用上下文, 应用实例挂载的整个组件树共享相同的上下文

- component 注册或检索全局组件

  - 参数
    - {string} name
    - {Function | Object} [definition]
  - 返回值
    - 传入 definition 参数，返回应用实例
    - 不传入 definition 参数，返回组件定义

  ```javascript
  import { createApp } from 'vue';
  const app = createApp({});
  // 注册一个名为 my-component 的组件
  app.component('my-component', {
    /* ... */
  });
  // 检索注册的组件(始终返回构造函数)
  const MyComponent = app.component('my-component');
  ```

- config 应用配置对象
- directive 注册或检索全局指令

  - 参数
    - {string} name
    - {Function | Object} [definition]
  - 返回值
    - 传入 definition 参数，返回应用实例
    - 不传入 definition 参数，返回指令定义

  ```javascript
  import { createApp, onCreated, onMounted } from 'vue';
  const app = createApp({});
  // 注册
  app.directive('my-directive', {
    // 指令是具有一组生命周期的钩子：
    // 在绑定元素的 attribute 或事件监听器被应用之前调用
    created(el, binding, vnode, prevNode) {},
    // 在绑定元素的父组件挂载之前调用
    beforeMount(el, binding, vnode, prevNode) {},
    // 绑定元素的父组件被挂载时调用
    mounted(el, binding, vnode, prevNode) {},
    // 在包含组件的 VNode 更新之前调用
    beforeUpdate(el, binding, vnode, prevNode) {},
    // 在包含组件的 VNode 及其子组件的 VNode 更新之后调用
    updated(el, binding, vnode, prevNode) {},
    // 在绑定元素的父组件卸载之前调用
    beforeUnmount(el, binding, vnode, prevNode) {},
    // 卸载绑定元素的父组件时调用
    unmounted(el, binding, vnode, prevNode) {},
  });
  // 注册 (功能指令)
  app.directive('my-directive', () => {
    // 这将被作为 `mounted` 和 `updated` 调用
  });
  // getter, 如果已注册，则返回指令定义
  const myDirective = app.directive('my-directive');
  ```

- mixin 将一个 mixin 应用到整个应用范围内

  - 参数
    - {Object} mixin
  - 返回值: 应用实例

  ```javascript
  import { createApp } from 'vue';
  const app = createApp({});
  app.mixin({});
  ```

- mount 挂载应用实例

  - 参数
    - {Element | string} rootContainer
    - {boolean} isHydrate
  - 返回值: 根组件实例

  ```javascript
  <body>
    <div id='my-app'></div>
  </body>;
  import { createApp } from 'vue';
  const app = createApp({});
  // 做一些必要的准备
  app.mount('#my-app');
  ```

- unmount 卸载应用实例的根组件

  ```javascript
  <body>
    <div id='my-app'></div>
  </body>;
  import { createApp } from 'vue';
  const app = createApp({});
  // 做一些必要的准备
  app.mount('#my-app');
  // 挂载5秒后，应用将被卸载
  setTimeout(() => app.unmount(), 5000);
  ```

- provide 设置一个可以被注入到应用范围内所有组件中的值

  - 参数
    - {string | Symbol} key
    - value
  - 返回值: 应用实例

  ```javascript
  import { createApp } from 'vue';
  const app = createApp({
    inject: ['user'],
    template: `
      <div>
        {{ user }}
      </div>
    `,
  });
  app.provide('user', 'administrator');
  ```

- use 安装 Vue.js 插件。如果插件是一个对象，它必须暴露一个 install 方法。如果它本身是一个函数，它将被视为安装方法

  - 参数
    - {Object | Function} plugin
    - ...options (可选)
  - 返回值: 应用实例

  ```javascript
  import { createApp } from 'vue';
  import MyPlugin from './plugins/MyPlugin';
  const app = createApp({});
  app.use(MyPlugin);
  app.mount('#app');
  ```

## 全局 API

- createApp 返回一个提供应用上下文的应用实例,应用实例挂载的整个组件树共享同一个上下文

  - 参数
    - {Object} rootConf 根组件选项对象
    - {Object} propConf 根 prop

  ```javascript
  import { createApp } from 'vue';
  const app = createApp(
    {
      props: ['username'],
      data() {
        return {};
      },
      methods: {},
      computed: {},
    },
    { username: 'Hello World' }
  );
  ```

- h 返回一个"虚拟节点",通常缩写为 VNode：一个普通对象，其中包含向 Vue 描述它应在页面上渲染哪种节点的信息,包括所有子节点的描述

  - 参数
    - {String | Object | Function} type
    - {Object} props
    - {String | Array} children

  ```javascript
  render() {
    // 使用返回 null 的函数将渲染一个注释
    return Vue.h('div', {}, [
      Vue.h(null, {}, [' Annotation start ']),
      Vue.h('h2', {}, ['Hello World']),
      Vue.h('p', {}, 'This is a label p, it contain description...'),
      Vue.h(null, {}, [' Annotation end '])
    ])
  }
  ```

- defineComponent 创建一个合成类型的构造函数,用于手动渲染函数、TSX 和 IDE 工具支持

  1. 具有组件选项的对象

     ```javascript
     import { createApp, defineComponent } from 'vue';
     const MyComponent = defineComponent({
       data() {
         return { count: 1 };
       },
       methods: {
         increment() {
           this.count++;
         },
       },
     });
     const app = createApp(MyComponent).mount('#app');
     ```

  2. 一个 setup 函数, 函数名称作为组件名称使用

     ```javascript
     import { createApp, defineComponent, ref } from 'vue';
     const HelloWorld = defineComponent(function HelloWorld() {
       const count = ref(0);
       return { count };
     });
     const app = createApp(HelloWorld).mount('#app');
     ```

- defineAsyncComponent 创建一个只有在需要时才会加载的异步组件

  1. 接受一个返回 Promise 的工厂函数

     ```javascript
     // 全局注册
     import { defineAsyncComponent } from 'vue';
     const AsyncComp = defineAsyncComponent(() => import('./components/AsyncComponent.vue'));
     app.component('async-component', AsyncComp);
     // 局部注册
     import { createApp, defineAsyncComponent } from 'vue';
     createApp({
       // ...
       components: {
         AsyncComponent: defineAsyncComponent(() => import('./components/AsyncComponent.vue')),
       },
     });
     ```

  2. 接受一个对象

     ```javascript
      import { defineAsyncComponent } from 'vue'
      const AsyncComp = defineAsyncComponent({
        // 工厂函数
        loader: () => import('./Foo.vue')
        // 加载异步组件时要使用的组件
        loadingComponent: LoadingComponent,
        // 加载失败时要使用的组件
        errorComponent: ErrorComponent,
        // 在显示 loadingComponent 之前的延迟 | 默认值：200（单位 ms）
        delay: 200,
        // 如果提供了 timeout ，并且加载组件的时间超过了设定值，将显示错误组件
        // 默认值：Infinity（即永不超时，单位 ms）
        timeout: 3000,
        // 定义组件是否可挂起 | 默认值：true
        suspensible: false,
        /**
        *
        * @param {*} error 错误信息对象
        * @param {*} retry 一个函数，用于指示当 promise 加载器 reject 时，加载器是否应该重试
        * @param {*} fail  一个函数，指示加载程序结束退出
        * @param {*} attempts 允许的最大重试次数
        */
        onError(error, retry, fail, attempts) {
          if (error.message.match(/fetch/) && attempts <= 3) {
            // 请求发生错误时重试，最多可尝试 3 次
            retry()
          } else {
            // 注意，retry/fail 就像 promise 的 resolve/reject 一样：
            // 必须调用其中一个才能继续错误处理。
            fail()
          }
        }
      })
     ```

- resolveComponent 允许按名称解析 component

  > resolveComponent 只能在 render 或 setup 函数中使用

  - 参数

    - {String} name 已加载的组件的名称

  - 返回值: 返回一个 Component, 如果找不到则返回接收的参数 name

  ```javascript
  const app = Vue.createApp({});
  app.component('MyComponent', {
    /* ... */
  })
  import { resolveComponent } from 'vue';
  render() {
    const MyComponent = resolveComponent('MyComponent');
  }
  ```

- resolveDynamicComponent 返回已解析的 Component 或新创建的 VNode，其中组件名称作为节点标签。如果找不到 Component,将发出警告

  > 允许使用与 &lt;component :is=""&gt; 相同的机制来解析一个 component

  > resolveDynamicComponent 只能在 render 或 setup 函数中使用

  - 参数
    - {String | Object} component 组件

  ```javascript
  import { resolveDynamicComponent } from 'vue';
  render () {
    const MyComponent = resolveDynamicComponent('MyComponent');
  }
  ```

- resolveDirective 允许按名称解析一个 directive

  > resolveDirective 只能在 render 或 setup 函数中使用

  - 参数
    - {String} name 已加载的指令名称
  - 返回值: 返回一个 Directive, 如果没有找到则返回 undefined

  ```javascript
  import { createApp, resolveDirective } from 'vue';
  const app = createApp({});
  app.directive('highlight', {});
  render () {
    const highlightDirective = resolveDirective('highlight');
  }
  ```

- withDirectives 允许将指令应用于 VNode。返回一个包含应用指令的 VNode

  > withDirectives 只能在 render 或 setup 函数中使用

  - 参数
    - {Element} vnode 使用 h() 创建的虚拟节点
    - {Array} directives 指令数组

  ```javascript
  import { withDirectives, resolveDirective } from 'vue';
  const foo = resolveDirective('foo');
  const bar = resolveDirective('bar');

  return withDirectives(h('div'), [
    [foo, this.x],
    [bar, this.y],
  ]);
  ```

- createRenderer 自定义渲染器可以传入特定于平台的类型

  - 参数
    - HostNode 宿主环境中的节点
    - HostElement 宿主环境中的元素

  ```javascript
  import { createRenderer } from 'vue';
  const { render, createApp } = createRenderer<Node, Element>({
    patchProp,
    ...nodeOps
  })
  ```

- nextTick 将回调推迟到下一个 DOM 更新周期之后执行

  ```javascript
  import { createApp, nextTick } from 'vue';
  const app = createApp({
    setup() {
      const message = ref('Hello!');
      const changeMessage = async (newMessage) => {
        message.value = newMessage;
        await nextTick();
        console.log('Now DOM is updated');
      };
    },
  });
  ```

- mergeProps 将包含 VNode prop 的多个对象合并为一个单独的对象, 返回一个新创建的对象, 而作为参数传递的对象则不会被修改.

  ```javascript
  import { h, mergeProps } from 'vue';
  export default {
    inheritAttrs: false,
    render() {
      const props = mergeProps(
        {
          // 该 class 将与 $attrs 中的其他 class 合并。
          class: 'active',
        },
        this.$attrs
      );
      return h('div', props);
    },
  };
  ```

## 选项

### Data

#### data

- vm.a 等价于 vm.$data.a
- 以 \_ 或 $ 开头的 property 不会被组件实例代理, vm.$data.\_property

#### props 用于接收来自父组件的数据

#### computed 计算属性

- 计算属性的结果会被缓存,依赖的响应式 property 变化才会重新计算

#### methods

#### watch

#### emits 定义组件触发的自定义事件

> emits 选项中列出的事件不会从组件的根元素继承，也将从 $attrs property 中移除

- Array&lt;string&gt; | Object

  ```javascript
  import { createApp } from 'vue';
  const app = createApp({});
  // 数组语法
  app.component('todo-item', {
    emits: ['check'],
    created() {
      this.$emit('check');
    },
  });
  // 对象语法
  app.component('reply-form', {
    emits: {
      // 没有验证函数
      click: null,
      // 带有验证函数
      submit: (payload) => {
        if (payload.email && payload.password) {
          return true;
        } else {
          console.warn(`Invalid submit event payload!`);
          return false;
        }
      },
    },
    mounted() {
      this.$emit('submit', { email: '', password: '' });
    },
  });
  ```

### DOM

#### template

> 如果 Vue 选项中包含渲染函数，该模板将被忽略

#### render

> render 函数的优先级高于从挂载元素 template 选项或内置 DOM 提取出的 HTML 模板编译渲染函数

### 生命周期钩子

> 所有的生命周期钩子自动绑定 this 上下文到实例中, 不能使用箭头函数来定义一个生命周期方法

#### beforeCreate

#### created

#### beforeMount

> 该钩子在服务器端渲染期间不被调用

#### mounted

> 该钩子在服务器端渲染期间不被调用

#### beforeUpdate

> 该钩子在服务器端渲染期间不被调用，因为只有初次渲染会在服务端进行

#### updated

> 该钩子在服务器端渲染期间不被调用

#### activated 被 keep-alive 缓存的组件激活时调用

> 该钩子在服务器端渲染期间不被调用

#### deactivated 被 keep-alive 缓存的组件停用时调用

> 该钩子在服务器端渲染期间不被调用

#### beforeUnmount

> 该钩子在服务器端渲染期间不被调用

#### unmounted

> 该钩子在服务器端渲染期间不被调用

#### errorCaptured 当捕获一个来自子孙组件的错误时被调用

- 参数
  - err: Error
  - instance: Component
  - info: string
- 返回值: 可以返回 false 阻止错误继续向上传播

#### renderTracked 跟踪虚拟 DOM 重新渲染时调用

- 参数
  - e: DebuggerEvent

#### renderTriggered 当虚拟 DOM 重新渲染被触发时调用

- 参数
  - e: DebuggerEvent

### 选项/资源

#### directives 包含组件实例可用指令的哈希表

#### components 包含组件实例可用组件的哈希表

### 组合

#### mixins

- Mixin 钩子按照传入顺序依次调用，并在调用组件自身的钩子之前被调用

#### extends 允许声明扩展另一个组件

#### provide / inject

> 允许一个祖先组件向其所有子孙后代注入一个依赖,不论组件层次深度

> provide 和 inject 绑定并不是响应式的 s

```javascript
// 父级组件 provide  'foo'
const Provider = {
  provide: {
    foo: 'bar',
  },
  // 或者是返回一个对象的函数
  // provide() {
  //   return {
  //     foo: 'bar',
  //   };
  // },
};
// 子组件 inject  'foo'
const Child = {
  inject: ['foo'],
  // 或者是一个对象
  // inject: {
  //   foo: {
  //     default: 'foo',
  //   },
  // },
  created() {
    console.log(this.foo); // => "bar"
  },
  // ...
};
```

#### setup 组合式 API 的入口点

- 在创建组件实例时, 在初始 prop 解析之后立即调用 setup
- 在生命周期方面, 在 beforeCreate 钩子之前调用
- 参数
  - props 接收父组件传入的属性, 不要结构 props 对象,会失去响应式
  - ctx 上下文对象, 包含了 attrs, slots, emit
- 返回值

  - Object 对象的属性合并到组件实例的上下文
  - h 返回一个渲染函数, 该函数可以直接使用在同一作用域中声明的响应式状态

    ```javascript
    import {h, ref, reactive} from 'vue';
    setup() {
      const count = ref(0)
      const object = reactive({ foo: 'bar' })
      return () => h('div', [count.value, object.foo])
    }
    ```

### 杂项

#### name

#### delimiters

- 默认值: ['{{', '}}'] 模板文本插值的分隔符

#### inheritAttrs

- 控制是否在子组件的根元素上显示不被认作 props 的 attributes 绑定

- 默认值: true
